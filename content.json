{"pages":[{"title":"About","text":"Hello, My name is Chung. I am a developer based in Tokyo, Japan.I basically do Web and iOS. This blog is where I save my memories, some useful tech tips and experiences while living in Japan. こんにちは、ブイタンチュンです。ブログをご覧いただきありがとうございます。このブログは主に仕事をしている時に気付き点のメモや学習の技術チュートリアルを記述します。\\","link":"/about.html"}],"posts":[{"title":"Centos7/Apache上HTTPSサーバーを作ってみる","text":"Apacheサーバー上HTTPSを構築してみた。 流れ CSRを作成する 証明書発行 サーバー設定 1. CSRを作成するCSR (Certificate Signing Request)は証明書発行依頼書と呼ばれ、CA(Certificate authority)へ提出するもの。作成時に以下の情報が重要となるので、メモしておいた。 Common Name (eg, your name or your server’s hostname) Domain name or server’s public IP address1.1. Private Key(機密鍵)発行openssl genrsa -out /path/to/.key 2048 1.2. CSR発行 (Certificate Signing Request)openssl req -new -key /path/to/.key -out /path/to/.csr 1.3. Private Keyからpassphraseを排除Passphraseを有効にしていると、サーバー再起動した際、Private Keyを認証する為、Passphraseが求められるので、入力完了するまで、\bWebsiteをアクセスできないことがある。 12cp server.key server.key.orgopenssl rsa -in server.key.org -out server.key 2. 証明書取得実際はCAに発行してもらうが、テスト時は自己署名証明書を使用する。このテストのようの証明書はself-signed certificateと呼ばれる。 1openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt 👉self-signed certificateを使用する場合、以下のコマンドでCSR発行せずに、直接証明書を生成することができる 1sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/apache-selfsigned.key -out /etc/ssl/certs/apache-selfsigned.crt req: X509によりCSR作成 x509: self-signed認証発行する指示 nodes: passphraseを使用しない days 365: 有効期限（１年） newkey rsa:2048長ビットのkeyと証明書同時に発行。(rsa key with 2048 bits long) keyout: private keyの作成場所 out: 証明書の置く場所 3. サーバー設定3.1. 設定ファイル修正/etc/httpd/conf.d/ssl.conf 12345678# プロトコルSSLProtocol -All +TLSv1 +TLSv1.1 +TLSv1.2# 証明書指SSLCertificateFile path/to/.crt# 鍵ファイル指定SSLCertificateKeyFile /path/to/.key 3.2. firewall 設定httpsアクセスを許可する 12firewall-cmd --add-service=https --permanentfirewall-cmd --reload","link":"/2017/11/02/centos-apache-https-server/"},{"title":"[Security]HTTP Security Headers","text":"X-XSS-Protection概要123X-XSS-Protection: 0; X-XSS-Protection: 1; X-XSS-Protection: 1; mode=block 設定方法1X-XSS-Protection: 1; mode=block 理由はこちらご覧ください platform どう設定するの Rails4,5 設定不要。(デフォルト有効） Django SECURE_BROWSER_XSS_FILTER = True Express.js Helmet Go unrolled/secure Nginx add_header: X-XSS-Protection “1; mode=block”; Apache Header always set X-XSS-Protection “1; mode=block” Content Security Policy (CSP)概要1Content-Security-Policy: &lt;policy&gt; 設定方法 platform どう設定するの Rails4,5 secureheaders Django django-csp Express.js helmet/csp Go unrolled/secure Nginx add_header Content-Security-Policy “”; Apache Header always set Content-Security-Policy “” 参照： https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy https://csp.withgoogle.com/docs/adopting-csp.html HTTP Strict Transport Security (HSTS)概要123Strict-Transport-Security: max-age=&lt;expire-time&gt;Strict-Transport-Security: max-age=&lt;expire-time&gt;; includeSubDomainsStrict-Transport-Security: max-age=&lt;expire-time&gt;; preload 設定方法 platform どう設定するの Rails 4 config.force_ssl = true; config.ssl_options = { hsts: { subdomains: true } } Rails 5 config.force_ssl = true Django SECURE_HSTS_SECONDS = 31536000; SECURE_HSTS_INCLUDE_SUBDOMAINS = True Express.js helmet Go unrolled/secure Nginx add_header Strict-Transport-Security “max-age=31536000; includeSubdomains; “; Apache Header always set Strict-Transport-Security “max-age=31536000; includeSubdomains; HTTP Public Key Pinning (HPKP)概要123Public-Key-Pins: pin-sha256=&lt;base64==&gt;; max-age=&lt;expireTime&gt;;Public-Key-Pins: pin-sha256=&lt;base64==&gt;; max-age=&lt;expireTime&gt;; includeSubDomainsPublic-Key-Pins: pin-sha256=&lt;base64==&gt;; max-age=&lt;expireTime&gt;; report-uri=&lt;reportURI&gt; 設定方法設定を推奨しない参照：https://blog.qualys.com/ssllabs/2016/09/06/is-http-public-key-pinning-dead X-Frame-Options概要123X-Frame-Options: DENYX-Frame-Options: SAMEORIGINX-Frame-Options: ALLOW-FROM https://example.com/ 設定方法 platform どう設定するの Rails4,5 config.action_dispatch.default_headers[‘X-Frame-Options’] = “DENY” Django X_FRAME_OPTIONS = ‘DENY’ Express.js helmet Go unrolled/secure Nginx add_header X-Frame-Options “deny”; Apache Header always set X-Frame-Options “deny” X-Content-Type-Options概要1X-Content-Type-Options: nosniff; MIME sniffingを防ぐヘッダ 設定方法 platform どう設定するの Rails4,5 デフォルト有効 Django SECURE_CONTENT_TYPE_NOSNIFF = True Express.js helmet Go unrolled/secure Nginx add_header X-Content-Type-Options nosniff; Apache Header always set X-Content-Type-Options nosniff Referrer-Policy概要12345678Referrer-Policy: \"no-referrer\"Referrer-Policy: \"no-referrer-when-downgrade\"Referrer-Policy: \"origin\"Referrer-Policy: \"origin-when-cross-origin\"Referrer-Policy: \"same-origin\"Referrer-Policy: \"strict-origin\"Referrer-Policy: \"strict-origin-when-cross-origin\"Referrer-Policy: \"unsafe-url\" 設定方法 platform どう設定するの Rails4,5 secureheaders Django Custom middleware Express.js helmet Go Custom middleware Nginx add_header Referrer-Policy “no-referrer”; Apache Header always set Referrer-Policy “no-referrer” 参照：https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy 参照：https://techtalk.vn/tat-ca-nhung-thu-ban-can-biet-ve-http-security-headers.html","link":"/2017/10/13/apache-security-header/"},{"title":"開発マシンのTips","text":"よく使われるコマンドをAliasに~/.zshrc or ~/.bash_profile or whatever you use 12# append this line to the bottomsource ~/.aliases ~/.aliases 12345678alias gs=\"git status\"alias gl=\"git log\"alias gaa=\"git add .\"alias gc=\"git commit -m \"alias gclean=\"git reset --hard &amp;&amp; clean -df\"alias projects=\"cd /Volumes/Data/projects \"alias p=\"phpunit \"alias pf=\"phpunit --filter \" 1source ~/.aliases これで gsはgit status、gcはコミットなど便利に使える。 複数Pythonバージョンがあっても、PATH変更せず、好みバージョン使用できるpython2とpython3が混在な環境ではpython3コマンドを打つのは面倒だね。 ~/.aliases 1alias python=\"python3\" デフォルトのTerminalより、Oh My ZSH!を使うメリットは様々だが、https://ohmyz.sh/をご確認ください Flutter Catalina error12345sudo xattr -d com.apple.quarantine ~/thanhchungbui/flutter/bin/cache/artifacts/libimobiledevice/idevice_idsudo xattr -d com.apple.quarantine ~/flutter/bin/cache/artifacts/libimobiledevice/idevice_idsudo xattr -d com.apple.quarantine ~/flutter/bin/cache/artifacts/libimobiledevice/ideviceinfosudo xattr -d com.apple.quarantine ~/flutter/bin/cache/artifacts/usbmuxd/iproxy","link":"/2018/06/23/mac-dev-tips/"},{"title":"基本情報技術者試験を合格してきた","text":"ちょっとした感想を残しておきます。 きっかけ部門の飲み会でこの試験の話が出て、結構チャレンジした人が多いので、自分もやってみようと思った。 受験後の感想すごい長くて、疲れたと印象。 午前問題は大体過去問題の使い回しなので、準備しておけば、できる感じ 午後問題日本語の長文まみれ、目が痛い。 試験で習得したこと プログラミングは普段にやっているから、問題ないけど、マネジメントとストラレテジ系はかなり勉強になった。プロジェクト進行まわりの知識も面白いなと思っている セキュリティの問題もかなり実際に近い課題を出したと思うので、勉強になった。 後、用語の覚える機会も遭ったね。 勉強方法 午前：過去問題を解くのは大事だね。私は過去5年分(10部）を解いてきた。 午後：数量ではなく、質だね。2, 3年分の問題を解いてみて、回答を確認し、全部理解するまでしっかり勉強した方が良いと思う。 試験についての感想試験の勉強過程でじっくり考える時間があるので、人により、習得できることが多いと思うね。ただ、全く未経験者にはあまり向いていない試験だと感じる。 今後の予定特に考えていないけど、セキュリティの知識を身に付けたいので、情報セキュリティマネジメント試験かな","link":"/2019/05/25/passed-fe-shiken/"},{"title":"[PHP]UTF-8 BOMにやられた","text":"最近、phpアプリケーションをリリースした時、とんでもないことに遭った。全画面が動かなくなった。 問題ソースコードを開発Linux環境からクラウド環境へリリースした後、なんだかブラウザにResponseコード200にも関わらず、「Gzipが不正よ」と文句され、画面表示ができない。確かにクラウド環境ではレスポンスのGzip圧縮を追加してるので、phpとgzip周辺に結構ハマった。 原因このシステムはかなり古いので、ob_start(&quot;ob_gzhandler&quot;);でgzipレスポンスを作っている。gzipレスポンスを分析したところ、なんとPHPソースファイルにBOMがついていて、不正なGzipを送信しているのが原因だった！\\ ※BOMはEF BB BFで確認可能 Windows上のエディターでは「UTF-8 BOM付で保存」という設定があって、この設定でファイル保存かもしれないよね。 対策全てUTF-8 BOM付のソースファイルを抽出し、BOMを消せば、正常に動いた。 BOM付きファイル抽出1grep -rl $'\\xEF\\xBB\\xBF' . BOMを排除する1sed -i '1 s/^\\xef\\xbb\\xbf//' *.php","link":"/2018/02/13/php-suck-bom-utf8/"},{"title":"Https Basic Memo","text":"Source: Source: StackOverFlow 日本語 ブラウザはhttps://payment.comに接続を成立する。 https://payment.comのサーバーはブラウザに証明書を送る。この証明書は公開鍵が含まれる。 ブラウザはhttps://payment.comの証明書は有効であるものを確認する。※ ステップ３を通過したら、ブラウザは新しい鍵（Kと呼ばれる）を生成し、https://payment.comの公開鍵を使って暗号化してからhttps://payment.comに送信する https://payment.comは機密鍵でKを複合化する ここからブラウザとサーバはKでデータ通信を行う。 Tiếng Việt. Browser sẽ truy cập 1 trang web https. Ở đây là https://payment.com Server hay Load Balancer (LB) của payment.com sẽ trả về certificate để chứng thực rằng website user đang truy cập là website chính thức. Trong certificate là một public key PK, dùng để mã hóa K ở bước 4. Browser sẽ kiểm chứng certificate (bằng cách chạy thuật toán kiểm tra chữ ký). Quá trình này giúp browser xác định https://payment.com là thật hay giả. Sau khi kiểm chứng được certificate, browser sẽ tự sinh ra 1 khóa K. Khóa K sẽ được dùng để mã hóa tất cả các liên lạc giữa browser và payment.com sau này. Do quá trình mã hóa các gói tin dùng mã đối xứng, khóa K cần được gửi trở lại payment.com vì nếu không có K, server (LB) không thể nào giải mã được gói tin. Khóa K được gửi trả lại cho payment.com. Phía payment.com sẽ dùng private key (được bảo vệ) để giải mã gói tin này và qua đó có được thông tin về K. payment.com và browser dùng khóa K để mã hóa toàn bộ dữ liệu liên lạc sau này. Certificate là một khối dữ liệu bao gồm rất nhiều thông tin về payment.com. Các thông tin này bao gồm: Tên domain Tên công ty sở hữu Thời gian certificate được cấp Thời hạn certificate Public key PK Làm thế nào browser kiểm chứng được certificate ở bước 3Bất cứ người nào đứng giữa browser và payment.com đều có thể làm giả certificate và public key. Bằng cách làm giả certificate, người đứng giữa có thể giả dạng payment.com. Bằng cách giả public key, người đứng giữa có thể dùng khóa private của mình để xem thông tin truyển tải giữa 2 bên. Vậy làm thế nào để ngăn chặn cách tấn công này. Cách giải quyết là: CA (Certificate Authority). CA là gì? Làm gì?Trong thực tế, để chứng minh một ai đó trình độ đại học, trường đại học nơi người đó học sẽ cấp cho họ một tấm bằng. Do tấm bằng đó có thể bị làm giả, ta cần một đơn vị chứng minh đó là bằng thật. CA chính là người chứng minh certificate mà payment.com cung cấp là thật! CA bán dịch vụ chứng thực đó bằng cách ký chứng minh rằng certificate của payment.com là thật Certificate chứng thực cho payment.com sẽ được CA ký bằng khóa bí mật của CA. Khóa này chỉ có CA biết và do vậy việc chữ ký là an toàn. payment.com sẽ gửi cho user certificate đã được ký bởi CA cùng với khóa công khai PK2 của khóa bí mật CA dùng để ký certificate. Browser sẽ tiến hành kiểm tra certificate này như bình thường dùng khóa công khai PK2 của CA. Đến đây vấn đề chưa thực sự được giải quyết vì, khóa công khai của CA cũng hoàn toàn có thể bị làm giả và do vậy certificate hoàn toàn có thể là giả! Giống như thực tế người chứng minh cho tấm bằng đại học cũng có thể bị làm giả. Để chắc chắn việc này, ta có thể ký chứng thực certificate do CA ký là thật. Cách làm có thể hoàn toàn tương tự là dùng khóa bí mật nào đó và ký tiếp và đính kèm khóa công khai PK3 với certificate sau khi được ký. Cứ thế ta có một dãy các certificate và khóa công khai mà certificate sau chứng thực cho certificate trước. Do bản chất đệ quy, ta cần điểm dừng là một certificate mà ta hoàn toàn tin tưởng. Đến đây ta có khái niệm root certificate. Root certificateRoot certificate là certificate mà ta hoàn toàn tin tưởng. Khi có certificate này, ta có thể tin tưởng những certificate mà được chứng thực bởi certificate này là hoàn toàn hợp lệ (giống trong thực tế là cơ quan công chứng!). Mỗi OS và browser có một danh sách các certificate mà OS và browser đó tin tưởng. Firefox tin tưởng các certificate có danh sách tại: https://wiki.mozilla.org/CA:IncludedCAsRHEL có danh sách các certificate tin tưởng tại: /etc/pki/tls/certs/ Do root certificate là certificate cuối cùng dùng để chứng thực các certificate trong chuỗi, khóa bí mật của certificate này cần được bảo vệ nghiêm ngặt. Bất cứ công ty cung cấp dịch vụ CA nào bị tấn công và bị mất khóa bí mật của root certificate đều rất nguy hiểm, bởi vì hackers có thể dùng khóa đó để ký certificate ở bước cuối cùng. Do browser và OS tin tưởng certificate này nên tất cả certificate, không nhất thiết do CA bị hack cung cấp, đều có thể bị làm giả. Các CA do vậy dùng rất nhiều công sức để bảo vệ thật kín đáo khóa bí mật này. Kinh doanh chứng thực CA là kinh doanh về mặt lòng tin, CA hứa sẽ đảm bảo tốt nhất khóa bí mật của họ và ta trả tiền để họ dùng khóa bí mật của họ ký. Theo đồn đại của giang hồ, verisign dùng cửa lock dày và các tay súng chuyên nghiệp cùng hệ thống truy cập phức tạp để bảo vệ khóa bí mật này. Xem certificate chain trong thực tếĐến đây ta chắc đã hiểu phần nào về cơ chế chứng thực cũng như cách hoạt động của HTTPS. Ta sẽ cùng xem chuỗi certificate trong thực tế. Facebook certificate được ký bởi DigiCert High Assurance CA-3. Bản thân CA-3 được chứng thực bởi EV RootCA. Các vấn đề liên quan đến https / certificateNguyên tắc hoạt động là như vậy, trong thực tế để duy trì và vận hành một hệ thống https cần tốn khá nhiều công sức. Dưới đây là một số case-studies mình gặp trong quá trình vận hành một website. Qua một số case-studies này hy vọng bạn sẽ hiểu tầm quan trọng của mỗi sự kiện và ý nghĩa của nó. HeartbleedSự kiện heartbleed là sự kiện đình đám của năm 2014. Heartbleed là lỗi bảo mật nằm trong bộ thư viện OpenSSL, bộ thư viện chủ đạo xử lý mã hóa trên Linux. Các webserver đều được build sử dụng OpenSSL nếu muốn phục vụ https. Heartbleed xảy ra khi openssl không kiểm tra độ dài trả về của một chuỗi ký tự và vô tình trả về thông tin nằm sau chuỗi ký tự này trên bộ nhớ. Vô tình phần bộ nhớ này bao gồm khóa bí mật được dùng để ký certificate ban đầu. Bằng cách hỏi máy chủ cho xem chìa khóa bí mật này, hacker có thể dùng nó để giải mã khóa mã hóa liên lạc ở bước 5 và do đó đọc được toàn bộ nội dung của phiên liên lạc. Heartbleed nguy hiểm bởi việc tấn công này hoàn toàn không để lại dấu vết. Các công ty cung cấp dịch vụ qua https đã phải xử lý vấn đề này bao gồm các bước sau: Nâng cấp phiên bản openssl Khởi động lại máy chủ web (apache, nginx) Tạo một khóa bí mật mới, certificate mới và yêu cầu CAs ký lại DiginostarDiginostar là hãng CAs của Hà Lan bị hacker tấn công và lấy được khóa bí mật. Từ đó tất cả các root certificate của Diginostar đều bị xóa bỏ khỏi browser, do lo sợ hacker sẽ dùng khóa bí mật này làm giả certificate. Điều này dẫn đến sự phá sản của CA. Qua đấy mới thấy việc bảo vệ khóa bí mật an toàn là vấn đề sống còn của các CAs. SuperfishHãng máy tính Lenovo khi bán máy tính đã cài thêm một phần mềm hiển thị quảng cáo đến người dùng. Khi người dùng lướt net, phần mềm này sẽ tự thêm một quảng cáo nhỏ trên browser. Để có thể thêm quảng cáo vào bất cứ chỗ nào, phần mềm này tự ý cài một root certificate vào máy lenovo bán đi. Root certificate này lại là một certificate tự ký, bất cứ ai có máy lenovo đều có thể có được khóa bí mật ký certificate này. Điều này vô tình biến tất cả người dùng máy lenovo thành đối tượng bị làm giả certificate. Tất cả các liên lạc https đều có thể bị làm giả, do vậy việc làm này đã tạo ra một lỗi bảo mật rất nghiêm trọng. Hãng Lenovo sau đó đã phải xin lỗi người dùng và đưa ra phần mềm gỡ bỏ tool này. http://support.lenovo.com/vn/vi/product_security/superfish_uninstall OS quá cũCác root certificate đi kèm với máy chủ không phải có thời hạn mãi mãi mà được làm mới qua mỗi lần release một phiên bản của OS. Do vậy việc update OS thường xuyên là điều nên làm. Tuy vậy đối với các máy chủ làm việc bận rộn, việc nâng cấp nhiều khi là điều khó khăn. Từ đây nảy sinh một vấn đề như sau. Máy chủ thỉnh thoảng hay phải gọi các https thông qua curl, ví dụ gọi twitter api qua https, hay gọi một dịch thanh toán nào đó qua Https. Giống như browser, curl dùng root certificate đi kèm để chứng thực các certificate phía dịch vụ gửi về. Tuy vậy khi root certificate hết hạn, việc chứng thực này sẽ thất bại, kéo theo việc app của bạn sẽ không chạy đúng nữa. Những lúc này việc update root certificate là việc cần phải làm. Kết luậnBài viết trình bày khái quát nguyên tắc hoạt động của https cũng như các vấn đề xoay quanh liên lạc dùng https. Hy vọng qua bài viết bạn hiểu rõ hơn về https cũng như lý giải được tầm nghiêm trọng của những vấn đề và sự kiện xoay quanh https. Bài này chủ yếu tham khảo và dịch lại 1 chút từ Nguồn Kipalog","link":"/2017/10/20/https-basic-memo/"},{"title":"[Shell]Shellで複雑なトランザクション制御方法","text":"問題psqlでSQLを指定して実行できるが、例えば複数SQLを同時に実行させ、また前のSQLの結果によって、続行するかしないかという条件付きの複雑SQLを実行することができない。 今回以下のようにShell scriptを作りたい。 123456789101112131415161718192021222324ConnectDb() { PGPASSWORD=postgres psql -U postgres database -t -A -F , -v ON_ERROR_STOP=1 -v AUTOCOMMIT=0}printMsg() { echo \"$PROGRAM/$SUBMODULE $(date \"+ %Y%H%s\")\" $1 | tee -a ~/Desktop/shell/log/test.log}ConnectDb &lt;&lt;EOF start transaction; select * from ...; # other database stubs # addtional operations like logging come here printMsg \"Querying ...\" # mix of conditional shell and psql command if [ some accepted condition ] commit; if [ some bad conditions ] rollback; if [ should do more database query ] do some CRUD actions commit;EOF 解決方法shellとSQLが混在する為、単純のpsqlに制御コマンドを入れることができない。 ちなみに、db2はこのようなshellscriptを簡単に作れる。 ここで、coprocを使えば、実現可能なことがわかった。 coprocの詳細はstackoverflowですごいわかりやすい回答があるので、ご参考ください。 psqlをバックグラウンドで動かせるpsqlにSQLを取り入れるSQLの実行結果を確認する","link":"/2017/08/02/shell-postgres-transaction-control/"},{"title":"[Postgres] current transaction is aborted, commands ignored until end of transaction block","text":"psqlや何かのSQLツールで、SQLを実行した時、このエラーが出ると、その後クエリが実行できなくなることがあったので、調べてみた。 原因は簡単だが、大量クエリを実行したので、気づかず、結構ハマった！ 原因Transaction内に一度エラーが発生すると、明示的にそのTransactionをabortしなければならないようだ。 SQL Server等の他のRDBMSだと、エラーが出てきても、その場で直して、処理を続けるんだね。 [例] 12begin;selet * from foo; このクエリを実行すると、「ERROR: syntax error at or near ‘selet’“」が出るはず。これで正しくselect * from foo;に修正し、再度実行をすると、冒頭のエラーが出て実行できなかった。因みに、sqlserverはこの問題が発生しないようだ。 対策エラーが出たら、 1rollback; を実行しなければならない。 なぜPostgresはそうなったのか？Postgresはユーザで終了したTransactionとシステムの都合(例外等）で終了したTransactionは区別しているようだ。https://github.com/postgres/postgres/blob/master/src/backend/access/transam/READMEを参照すると、 システムの都合でTransactionが終了した場合：AbortCurrentTransaction アプリケーション状態はTBLOCK_ABORT ユーザでTransactionを終了した場合：UserAbortTransactionBlock アプリケーション状態はTBLOCK_ABORT_END ケース１でも自動にTransactionを終了させれば良いでしょうかって思うよね。実はそれに応じるonerrorrollbackオプションがあるが、やっぱり長いTransaction内にエラーが発生したら、最初から実施しないといけない点は不便が感じるよね〜onerrorrollbackについての詳細説明も是非ご参照ください。https://www.endpoint.com/blog/2015/02/24/postgres-onerrorrollback-explained","link":"/2018/01/11/postgres-current-transaction-is-aborted/"},{"title":"Kinh nghiệm làm thủ tục gửi trẻ đi học nhà trẻ","text":"Việc gửi trẻ ở Nhật không giống với Việt Nam là thích gửi đâu cũng được, mà trước tiên bạn phải nộp hồ sơ xếp hàng và nếu đủ điều kiện thì mới được đi học.Khá là vất vả. Gần đây mình cũng mới làm thủ tục cho thằng cu ở nhà nên note lại 1 số kinh nghiệm. Sơ lượcHệ thống giáo dục mầm non ở Nhật là tự nguyện, và do 自治体(quận, thành phố) quản lý. Gồm các loại trường: 認可保育園 認定こども園 Ngoài ra tuỳ thành phố còn có: 認定こどもルーム Trẻ dưới 3 tuổi được khuyến khích tốt nhất nên ở với Bố Mẹ nên nếu không có lý do chính đáng, không thể xin cho con đi học được.Chỉ có mấy trường hợp dưới đây là xin được. Cả Bố và Mẹ đều đi làm full time.(共働き) Bố hoặc Mẹ đi full time, người còn lại đi học &gt; 64h/tháng Bố hoặc Mẹ đi full time, người còn lại đi làm part time &gt; 64h/tháng Các thủ tục cần thiết 就労証明書: giấy chứng nhận đi làm 在学証明書: giấy chứng nhận đi học スケジュール表:trong trường hợp đi học 申込書:Tờ khai nguyện vọngNếu đang tìm việc thì cần nộp 承諾書 Việc khai tờ nguyện vọng thì lúc đầu mình chỉ viết có 3 trường, sau đấy đi nộp thì họ nói cứ viết càng nhiều càng tốt.Vả kết cục là mình khai nguyện vọng những 20 trường. Xét duỵệt thế nàoSau khi nộp hồ sơ thì họ sẽ đánh giá và cho bạn 1 số điểm tương ứng. Nếu còn chỗ trống thì sẽ ưu tiên người có điểm số cao hơn vào trước. Thời gian xếp hàng không phải là hạng mục đánh giá nên cho dù bạn có xếp 1 năm mà luôn luôn có người điểm cao hơn bạn đang chờ thì bạn cũng không được vào. Học phíDựa vào mức đóng thuế thị dân (住民税)để quyết định. Trẻ dưới 3 tuổi thì phải đóng học phí (học phí đã bao gồm cả tiền ăn uống) Trẻ trên 3 tuổi thì được miễn học phí, chỉ phải đóng tiền ăn hàng tháng. Kết quả不承諾! Sau đó thì họ có gọi và thông báo rằng trượt 保育園 nhưng ベビールーム thì vẫn còn chỗ trống nên có muốn vào không?ベビールーム thường chỉ là 1 phòng rất bé mà học phí lại đắt. Mình cho con học được ở đấy gần 1 tháng thì phường gọi báo đỗ nguyện vọng 10😅Thế là lại khăn gói chuyển trường.","link":"/2019/03/20/thu-tuc-gui-tre/"},{"title":"Thủ tục visa thăm thân - bảo lãnh Bố Mẹ sang Nhật chơi","text":"Tham khảohttps://www.vn.emb-japan.go.jp/itpr_ja/VN_SVisaFAM.html Người xin visa Hộ chiếu\\ -&gt; Bản gốc2. Tờ khai visa (có dán ảnh)-&gt; 1 bản gốchttps://www.vn.emb-japan.go.jp/itpr_ja/VN_SVisaFAM.html Tài liệu chứng minh quan hệ họ hàng với người mời\\ -&gt; Sổ hộ khẩu: Mang theo 1 bản gốc và 1 bản photo Giấy tờ đặt vé (Khi nhận đc visa mới thanh toán)\\ -&gt; Bản gốc Người mời và bảo lãnh Giấy lý do mời\\ -&gt; BẢN GỐC-&gt; Danh sách người xin visa-&gt; Chú ý đóng dấu Lịch trìnhChú ý là file này không thể lưu được nên viết xong phải in luôn Nếu người mời bảo lãnh sang thì cần thêm:3. Giấy chứng nhận bảo lãnh gồm-&gt; Giấy chứng nhận bảo lãnh 1 BẢN GỐC -&gt; Chú ý đóng dầu-&gt; Giấy chứng nhận nộp thuế có ghi tổng thu nhập-&gt; Giấy số dư ngân hàng-&gt; Phiếu công dân-&gt; Photo 2 mặt thẻ ngoại kiều-&gt; Photo hộ chiếu trang ảnh và trang liên quan đến xuất nhập cảnh và lưu trú-&gt; Giấy chứng nhận đang làm việc xin từ công ty (在籍証明書) Gửi giấy tờ về Việt Nam Ra 郵便局 gửi chuyển phát nhanh EMS về Việt Nam. Chi phí hết khoảng 2000 yên tuỳ vùng Sau bao lâu thì xong thủ tục Khoảng 2 ngày - 1 tuần là nhận được là người ở Việt Nam nhận được giấy tờ Làm thủ tục ở Việt Nam mất khoảng 8 ngày làm việc -&gt; Tổng thời gian từ lúc làm giấy tờ đến lúc có visa khoảng 3 tuần nhưng các bạn nên làm trước khoảng 2 tháng để đề phòng tính huống phát sinh.","link":"/2018/12/15/thu-tuc-moi-gia-dinh-sang-nhat-choi/"},{"title":"Thuê nhà ở Nhật","text":"Nhìn chung do có sự khác biệt lớn về văn hoá và người Nhật thì thường kỹ tính nền người nước ngoài khá là khó thuê nhà ở Nhật. Mình cũng từng trải qua vài lần thuê nhà nên xin chia sẻ 1 chút ở đây 1. Share houseNếu còn độc thân, thì share house là 1 lựa chọn khá tốt. Với chi phí hạn hẹp bạn vẫn có thể ở 1 căn nhà gần trung tâm và tiện nghi đầy đủ.Đặc biệt là thủ tục không lằng nhằng. Ưu điểmCơ bản thì 1 căn nhà lớn được chia làm nhiều phòng chung nhau nhà bếp và nhà tắm.Tuỳ theo mức giá tiền thì chất lượng phòng sẽ khác nhau nhưng nhìn chung: 1 người/phòng, đầy đủ đồ chỉ việc xách valy vào ở Các thiết bị như đồ bếp, nhà tắm khá mới và hiện đại, có người dọn vệ sinh hàng tuần và chuẩn bị giấy vệ sinh hay nước rửa bát, … Với giá cả tầm 5-8man là có thể ở gần khu trung tâm tokyo, rất tiện cho việc đi lại Dễ dàng giao lưu kết bạn Hạn chế Tuy phòng riêng nhưng cách âm không tốt nên cần chú ý tiếng ồn. Chỗ mình từng ở thì mấy bạn nước ngoài như Brazil và Đức thì rất dễ nói chuyện và hay ngồi giao lưu với nhau nhưng thi thoảng cũng bị bạn Nhật than phiền về việc ồn ào. Vẫn đề riêng tư như thư từ khá bất cập. Thuê ở đâu?Mình thuê ở chỗ này: https://gghouse.co.jp/Hỗ trợ cả tiếng Anh, Việt, thủ tục rất dễ dàng 2. Thuê nhà riêngCái này thì phức tạp hơn 1 chút và cũng đắt hơn sharehouse tương đối.Các công ty bất động sản đều có hỗ trợ người nước ngoài nên các bạn cứ mạnh dạn bước vào hỏi thôiCó các loại như マンション: nhà chung cư アパート: nhà trọ, thường là nhà thấp khoảng 2 - 3 tầng, giá tương đối rẻ Chọn công ty BDSRa ga khu vực muốn thuê nhà rồi tìm cong ty bất động sản. Mình chọn Able vì chi phí môi giới chỉ bằng nửa so với chố khác. Các khoản phí đầu vào 仲介料 Phí môi giới: 1/2 ~ 1 tháng tiền nhà クリーニング Phí dọn dẹp nhà lần đầu (tuỳ nhà), 0 ~ 1 tháng tiền nhà 鍵交換 Phí thay chìa khoá: 0 ~ 3man 敷金 Đặt cọc từ 1 ~ 2 tháng tiền nhà 礼金 Tiền lễ 0 ~ 2 tháng tiền nhà 保証料 Phí thuê công ty bảo lãnh thuê nhà 1 man ~ 1tháng tiền nhà Khoản này hầu như là bắt buộc. Công ty này sẽ đứng ra chịu trách nhiệm với bên cho thuê về việc đóng tiền nhà hàng tháng của bạn7. Ngoài ra tuỳ nhà còn phải nộp thêm 2 - 4 tháng tiền nhà trước Phù😂 Phí thường niên 保証料: 1 năm 1 lần 更新料 phí gia hạn hợp đồng, 2 năm 1 lần 1 ~ 2 tháng tiền nhà","link":"/2018/04/12/thue-nha-o-nhat/"},{"title":"[Security]Web Application Security Checklist","text":"最近セキュリティ考慮したシステム設計を経験したので、メモします。 1. ユーザー認証 ログイン失敗する際詳しメッセージが出さない 指定回数でログイン失敗したらアカウントロックをかかる アカウントロックをかかった際管理者にメール等で通知 パースワードの有効期限を実装 パースワード変更するには現在のパースワードが必要 直接パースワードはDBに保存しない2. 権限制御 直接URLをアクセス許可かどうか検討 各アクションは実行する前に権限をチェックする ボタンの表示、非表示等ではなくロジック実装である。 ブラウザの戻るボタンを要注意3. セッション管理 Cookieセンシティブデーターを持たない SessionIdはユニックであり、サーバー側にてアサインするべき SessionIdは推測しにくい SessionIdはできればライフタイムが短く設定するべき ログアウトする際SessionIdは廃棄するべき CookieはHttpOnly,Secure属性設定するべき パーマネントCookieよりセッションCookieを使用したほうが良い4. バリデーション クライアントからのデータは信頼性がゼロとして必ずサーバーサイドバリデーション実装 HTML特殊文字、危険な文字等エスケープするべき5. クロスサイトスクリプティング 動的な内容を表示する箇所はすべてHTMLエスケープするか確認 Query stringのデータは直接表示させない6. コマンドインジェクション シェルコマンドが直接呼び出す際パラメータエスケープをするべきだ7. SQLインジェクション SQLを組み立てる際ストリング結合ではなくすべてprepare statementを使用するべき8. バッファオーバーフロー すべてのリクエストデータは最大値をバリデーションする9. 暗号化,秘密情報 認証されたアルゴリズムを使用すること 秘密鍵、DB情報等を持っている.envファイルは保護すること10. エラーハンドリング エラーになった際エラー情報をユーザーに見せないこと11. ロギング ログには日付、タイプ、詳細情報が出される12. サーバー設定 Debugモードオフする すべてリクエストはHTTPSを介すること Apacheサーバーの場合はApacheチェックリスト参照する","link":"/2017/12/11/web-application-security-checklist/"},{"title":"[PHP]Windows Case Insensitive Problem","text":"while developing in languages that are case-insensitive like php, be careful if development OS and production OS are acting differently at case-sensitivity, otherwise, some weird things will happen. For example, the code below works well in Windows 12345// filename: app/Models/Userorder.phpnamespace App\\Models;class UserOrder {} usage 1new \\App\\Models\\UserOrder(); Did you notice the difference between file name and class name? Because php use autoload to correctly load the file and class at runtime, in the declaration 1new \\App\\Models\\UserOrder(); first it will try loading the file app/Models/UserOrder.php and instance UserOrder object. As Windows is case-insensitive, UserOrder.php == Userorder.php, no problem here, but in Linux, you will get Fatal error: Class UrderOrder not found In that case, change the file name that matches the class name 1app/Models/Userorder.php -&gt; app/Models/UserOrder.php","link":"/2017/05/24/windows-case-insensitive-problem/index/"},{"title":"Vue Js Tips","text":"Bootstrap VueQ1. How to use router-link in b-nav-item1&lt;router-link :to=&quot;{path: 'home'}&quot;&gt;&lt;/router-link&gt; 1&lt;b-nav-item tag=&quot;router-link&quot; :to=&quot;{path: 'home'}&quot;&gt;&lt;/b-nav-item&gt; Q2. How to pass props to child route?Use set props = true inside route definition 1{path: &quot;/articles/:id&quot;, name: &quot;article_details&quot;, component: ArticleDetails, props: true}, Usage 1&lt;router-link :to=&quot;{name: 'article_details', params: {article: article}}&quot;&gt;Article 1&lt;/router-link&gt;","link":"/2020/02/01/vue-js-tips/index/"},{"title":"[Docker]メモ","text":"Docker上開発環境を構築してみた Stack: php, Laravel, nginx, postgres 各環境ファイル作成docker-compose.yml 1234567891011121314151617181920212223242526272829version: '3'services: nginx: build: ./nginx ports: - 8080:80 volumes: - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf - ./src:/var/www/app depends_on: - web web: build: ./src volumes: - ./src:/var/www/app depends_on: - db db: image: 'postgres:9.3' ports: - \"5432:5432\" env_file: - ./data/env_file volumes: # - ./data/postgres:/var/lib/postgresql/data - pgdata:/var/lib/postgresql/data# volumes:# pgdata: data/env_file 123POSTGRES_USER=postgresPOSTGRES_DB=my_dbPOSTGRES_PASSWORD=postgres nginx/nginx.conf 123456789101112131415161718192021server { listen 80; server_name app; root /var/www/app; index index.php index.html; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { fastcgi_pass web:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; }} サービスを起動バックグランドで起動1docker-compose up -d ここでweb, nginx, dbの３サービスが立ち上がって、localhost:8080アクセスできる 再ビルドしてから起動1docker-compose up -d --build 解説 Dockerはデータを持たない為、再起動するとデータ損失 データ損失を防ぐ為、volumesを使用する postgresイメージはenv_fileの情報でデータベースを作成する postgresのデータをvolumesに格納すれば、データ維持できる 12volumes: - ./data/postgres:/var/lib/postgresql/data Windows環境ではなんだかこのようなvolumesマウントしかたは上手く行きそうにないのでで、ネームvolumesに修正した FATAL: data directory “/var/lib/postgresql/data” has wrong ownership 1234 volumes: - pgdata:/var/lib/postgresql/datavolumes: pgdata: docker-compose up -dを実行すると、以下が起こる myapp_defaultネットワークが作られる。 web, nginx, dbの３サービスが作成され、myapp_defaultにジョイン myapp_defaultネットワーク環境下で、名前でアクセス可能。例webからdbでデータベースをアクセス、nginxでwebを使って、webをアクセス\\","link":"/2018/04/30/docker-memo/index/"},{"title":"Anchor Phishing","text":"バーナーとかで他サイトと連携することが普通だが、無害と考えているのに、不注意すると脆弱性がでてくることはご存じですか。意外と見逃しがちの攻撃なので、メモしておきます。 問題aタグで他サイトへ遷移する時に、遷移先ページでは現ページのlocationオブジェクトにアクセスができてしまって、悪質なアクションを行うことができる。 具体的どんなことが起こりえる あなたのサイトに他サイト遷移のリンク配置 ユーザーはリンクをクリックして、新しいタブで開く ユーザーはあなたのサイトのタブに戻る \\ 3は知らないうちに、あなたとのそっくりページが表示されている！！！ あなとのサイトへアクセスする スポンサーページをクリックし、○○株式会社サイトへアクセスする 1のタブに戻って、ログインをする ここで変わった点を気づいたか リンクURL：yoursite.com -&gt; y0ursite.com 画面がそっくりだね。（デモの目的でメッセージを出したけど） 対策 aタグに rel=”noopener noreferrer” 属性を追加 まとめ 外部ページへアクセスするリンクは全てrel=”noopener noreferrer”に設定すること 本脆弱性は自サイトの問題ではなく、連携先側で攻撃を受けられた際、悪影響を及ぼす対策の必要なものである。","link":"/2018/08/17/anchor-phishing/index/"},{"title":"[PHP]Empty関数の問題","text":"123if (empty($someVar)) { // do something} こんなのコードを書いたことがありますか。 Objectはnullかどうか、文字列の場合は&quot;&quot;かどうか、数値は0かどうか、配列は[]かどうか等とても便利なメソッドですね。 でも、今回はこんな簡単なことで、膨大なシステムの検討し、修正に至りました。 問題https://www.php.net/manual/ja/function.empty.phpによると、次のような値は空であるとみなされます。 “” (空文字列) 0 (整数 の 0) 0.0 (浮動小数点数の 0) “0” (文字列 の 0) NULL FALSE array() (空の配列) なんと“0”の文字列なのに、空とみなされています！！ これだと、例えば必須項目に”0”を入力したにも関わらず、未入力として変な処理になったりとか。。。 残念ながら、携わっているシステムはみんなemptyでしたので、再検討、修正、リリースに大変なことでした。 対策 新しいis_blank関数を作りました。 12345if (!function_exists('is_blank')) { function is_blank($value) { return empty($value) &amp;&amp; !is_numeric($value); }} Unit test 12345678910111213141516171819202122232425262728293031323334class IsBlankTest extends TestCase{ public function testIsBlank() { $input = '文字列'; $this-&gt;assertFalse(!isset($input) || is_blank($input)); $input = ''; $this-&gt;assertTrue(!isset($input) || is_blank($input)); $input = ' '; $this-&gt;assertFalse(!isset($input) || is_blank($input)); $input = 0; $this-&gt;assertFalse(!isset($input) || is_blank($input)); $input = 0.0; $this-&gt;assertFalse(!isset($input) || is_blank($input)); $input = '0'; $this-&gt;assertFalse(!isset($input) || is_blank($input)); $input = null; $this-&gt;assertTrue(!isset($input) || is_blank($input)); $input = false; $this-&gt;assertTrue(!isset($input) || is_blank($input)); $input = []; $this-&gt;assertTrue(!isset($input) || is_blank($input)); $this-&gt;assertTrue(!isset($undefinedVar) || (empty($undefinedVar) &amp;&amp; !is_numeric($undefinedVar))); }} 使いかた 123if(!isset($someVar) || is_blank($someVar)) { // do something} 最後に人を聞くと、こんな書き方は結構使われているようなので、この記事を読んでいただいた人に、こんなことにならないように願っています。","link":"/2019/09/24/php-empty/index/"},{"title":"Postgres Memo","text":"Useful Postgres command1. Move DB to another server1pg_dump -C -h sourceip -U username password | psql -h destinationip -U username 2. Init, start, restart123initdb -D /path/to/data/folderpg_ctl -D /path/to/data/folder startpg_ctl -D /path/to/data/folder restart 3. Config file pg_hba.config: use to config authentication method postgres.conf: use to config listenning host, etc. 4. Config authentication For server 1234vim /path/to/pg_hba.conf# add the following line:host all all 10.0.0.70/32 md5# change IP address For clientCreate ~/.pgpass and add the following line 1host:port:dbname:usr:pwd change permission 1chmod 0600 ~/.pgpass","link":"/2017/07/24/postgres-memo/index/"},{"title":"[Flutter]iOSアプリチュートリアルPart3 - Navigator、応用Widget","text":"ゴール Navigatorで画面遷移 Routeをカスタマイズ Widgetの構成の応用 Part2では基本的なWidgetを学習し、ホーム画面を作りました。今回は画面遷移Navigatorと残りの画面を作りましょう。 事前準備：Simulatorを立ち上げて、Intellijでデバッグ起動 少しThemeデータをカスタマイズ123456789101112131415161718192021class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { final theme = ThemeData( primarySwatch: Colors.purple, ); return MaterialApp( theme: theme.copyWith( primaryColor: Colors.white, primaryIconTheme: theme.primaryIconTheme.copyWith(color: Colors.grey), primaryColorBrightness: Brightness.light, primaryTextTheme: theme.textTheme, appBarTheme: theme.appBarTheme.copyWith( elevation: 1.0, ), ), home: HomePage(), ); }} NavigatorFlutterでは画面のことはroutesと言います。route遷移はNavigatorで行います。流れ routesを作成（インスタンス）、例A routeとB route Navigator.push()でB routeへ遷移します。 Navigator.pop()でA routeに戻ります。 MovieDetailPage遷移 main.dartに詳細画面を追加1234567891011class MovieDetailPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Details'), ), body: Container(), ); }} Movies一覧をタップすると、詳細画面へ遷移します。1234567891011Expanded( child: ListView.separated( itemBuilder: (context, index) { // 1. return ListTile( onTap: () { // 2. Navigator.push(context, MaterialPageRoute(builder: (context) =&gt; MovieDetailPage())); }, title: Container( // 略 ListTile:リストアイテムを定義する際によく出てくるパターンが用意され、便利なWidgetです。Avatar, Title, Subtitle, AccesoryView等が簡単に宣言できます。 MaterialPageRouteで画面遷移を行います。他にはCupertinoPageRouteがあります。 Routeをカスタマイズ、SearchPage作成Youtubeのように、🔎をタップすると、アニメションなしで検索画面へ遷移します。 123456class NoAnimationRoute extends MaterialPageRoute { NoAnimationRoute({WidgetBuilder builder}) : super(builder: builder); @override Duration get transitionDuration =&gt; Duration.zero;} 検索ボタンを追加12345678910111213141516171819202122232425262728class SearchPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( leading: IconButton( icon: Icon(Icons.arrow_back), onPressed: () { Navigator.pop(context); }, ), title: TextField( decoration: InputDecoration( border: InputBorder.none, hintText: &quot;Search&quot;, ), ), actions: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.clear), onPressed: () {}, ) ], ), body: Container(), ); }} MovieDetailPageを作成SliverAppBarSliverAppBarはAppBarとの同じ役割だが、高さが調整や表示内容が変更することができます。 12345678910111213141516171819202122232425262728293031class MovieDetailPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( // 1. body: CustomScrollView( slivers: &lt;Widget&gt;[ SliverAppBar( expandedHeight: 220, pinned: true, elevation: 0, flexibleSpace: FlexibleSpaceBar( title: Text(\"Joker\"), background: Stack( children: [ Positioned.fill( child: Container(color: Colors.blue), ), ], ), ), ), // 2. SliverList( delegate: SliverChildListDelegate() ), ], ), ); }} SliverAppBarを使う為に、CustomScrollViewを使用します。標準のAppBarも不要になるので、削除しました。 SliverList: CustomScrollViewに対応する特別Listです。 Custom Avatar Widget使用箇所が多いので、共通Widgetにしましょう。 123456789101112131415class Avatar extends StatelessWidget { final double width; final double height; const Avatar({Key key, this.width, this.height}) : super(key: key); @override Widget build(BuildContext context) { return Container( width: width, height: height, color: Colors.green, ); }} 画面作成 ポイント 全体はListで構成 横方向スクロール行はHorizontal Listを使います。 アイテムをタップする為に、InkWellを使います。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168const divider = Divider(height: 1.0);class MovieDetailPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( body: CustomScrollView( slivers: &lt;Widget&gt;[ SliverAppBar( expandedHeight: 180, pinned: true, elevation: 0, flexibleSpace: FlexibleSpaceBar( title: Text(\"Joker\"), background: Stack( children: [ Positioned.fill( child: Container(color: Colors.blue), ), ], ), ), ), SliverList( delegate: SliverChildListDelegate( [ // Poster Padding( padding: const EdgeInsets.all(10.0), child: Row( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Avatar(width: 90, height: 120), SizedBox( width: 15, ), ], ), ), divider, // Reviews Container( padding: EdgeInsets.symmetric(horizontal: 15, vertical: 15), child: Text( 'reviews', style: Theme.of(context).textTheme.subhead, ), ), divider, // Overview Container( padding: EdgeInsets.all(10), child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Text('Overview:', style: Theme.of(context).textTheme.title), SizedBox(height: 5), Text( \"During the 1980s, a failed stand-up comedian is driven insane and turns to a life of crime and chaos in Gotham City...\", style: Theme.of(context).textTheme.body2, ), ], ), ), divider, // Cast Container( padding: EdgeInsets.all(10), child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Text('Cast', style: Theme.of(context).textTheme.title), SizedBox(height: 5), Container( height: 130, child: ListView.builder( itemBuilder: (context, index) { return InkWell( onTap: () { Navigator.push(context, MaterialPageRoute(builder: (context) { return PersonPage(); })); }, child: Container( height: 180, width: 80, padding: EdgeInsets.symmetric(horizontal: 10), child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Avatar(width: 60, height: 90), SizedBox(height: 5), Text( \"Johnson\", maxLines: 1, textAlign: TextAlign.center, ), Text( \"Author\", maxLines: 1, textAlign: TextAlign.center, ), ], ), ), ); }, scrollDirection: Axis.horizontal, ), ) ], ), ), divider, // Crew Container( padding: EdgeInsets.all(10), child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Text('Crew', style: Theme.of(context).textTheme.title), SizedBox(height: 5), Container( height: 130, child: ListView.builder( itemBuilder: (context, index) { return Container( height: 180, width: 80, padding: EdgeInsets.symmetric(horizontal: 10), child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Avatar(width: 60, height: 90), SizedBox(height: 5), Text( \"Johnson\", maxLines: 1, textAlign: TextAlign.center, ), Text( \"Author\", maxLines: 1, textAlign: TextAlign.center, ), ], ), ); }, scrollDirection: Axis.horizontal, ), ) ], ), ), divider, ], ), ) ], ), ); }} プロファイル画面を作成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112const _padding = EdgeInsets.all(10);class PersonPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\"Johnson\"), ), body: ListView( children: &lt;Widget&gt;[ // Avatar Container( padding: EdgeInsets.all(10), child: Row( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Container( width: 70, height: 100, color: Colors.green, ), SizedBox(width: 10), Column( children: &lt;Widget&gt;[Text(\"Known for\"), Text(\"Acting\")], ) ], ), ), divider, // Biography Container( padding: _padding, child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Text('Biography'), Text( \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temportempor\", maxLines: 3, ), Text('Place of birth'), Text(\"San Juan, Puerto Rico\"), ], ), ), divider, // Images Container( padding: EdgeInsets.only(bottom: 20), child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Padding( padding: _padding, child: Text(\"Images\"), ), Container( height: 100, child: ListView.builder( itemBuilder: (context, index) { return Padding( padding: const EdgeInsets.symmetric(horizontal: 5), child: Avatar(width: 70, height: 100), ); }, scrollDirection: Axis.horizontal, ), ) ], ), ), divider, // Movie list Container( color: Colors.grey.shade200, padding: EdgeInsets.symmetric(horizontal: 10, vertical: 5), child: Text(\"Upcoming\"), ), divider, ...List.generate( 10, (index) =&gt; Container( padding: EdgeInsets.all(10), child: Row( children: &lt;Widget&gt;[ Avatar( width: 80, height: 110, ), SizedBox(width: 10), Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Text(\"Far BrightStar\"), ], ), ) ], ), ), ), ], ), ); }} まとめ今回は全画面を作りましたね。作り込みは簡単ですが、これぐらいWidgetを使いこなせば、基本的により複雑な構成の画面も作れると思いますので、手を触れてみてください。ただ、現在の画面は何もアクションができず、static画面ので、次回はインタラクションを追加しましょう。","link":"/2019/09/10/flutter/movie-app-tutorial-part3/index/"},{"title":"[Flutter]iOSアプリチュートリアルPart2 - 基本Widget","text":"前回はFlutterについて紹介とアプリのWireframeを作りました。これから、コードを手がけましょう。 ゴール 基本のWidgetを理解 レイアウトベーシック ホーム画面 事前準備 Simulator起動Terminal上にflutter runを実行 Hello Worldmain.dartの内容を全部削除し、以下のコードを挿入 123456789101112131415161718192021222324252627import 'package:flutter/material.dart';// 1.void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { // 2. return MaterialApp( theme: ThemeData(primarySwatch: Colors.purple), home: HomePage(), ); }}class HomePage extends StatelessWidget { @override Widget build(BuildContext context) { // 3. return Scaffold( appBar: AppBar( title: Text('Home'), ), body: Container(), ); }} main():例の入り口ですね。アプリのDependencyの初期化理想な場所 ES6のArrow関数と似ている構文ですね。// TODO Dart 関数記載 MaterialApp: Widget Treeの最上位。テーマやルーティング定義 テーマ色がたくさん内臓されるので、好きに試みてください。 Scaffold: Materialデザインの画面レイアウトを定義するWidget基本はappBarとbodyが含まれます。また、 Drawer、 Snackbar, BottomSheetを使用する為、APIも用意されています。 ホーム画面レイアウト1234567891011121314151617181920class HomePage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Popular'), ), // 1. body: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ // 2. Container(height: 40, color: Colors.blue, child: Center(child: Text('ショートカットボタン'))), // 3. Expanded(child: Container(color: Colors.green, child: Center(child: Text('Movie一覧')))), ], ), ); }} Column:子供を縦方向並んで、反対はRowWidgetがあります。 定義の通り、高さ40の青ボックス(Container)を用意し、真ん中(Center)にテキスト(Text)を配置します。 Expanded:Columnは高さ変動するので、可能な範囲、全スペースを使用したい時使用されるWidgetです。 ショートカットボタン123456789101112131415161718192021body: Column( children: &lt;Widget&gt;[ Container( padding: EdgeInsets.all(10), // 1 child: ToggleButtons( children: &lt;Widget&gt;[ Text('Popular'), Text('Top Rated'), Text('Upcoming'), Text('Now Playing'), ], onPressed: (index) { // TODO: implements }, isSelected: &lt;bool&gt;[true, false, false, false], ), ), Expanded(child: Container(color: Colors.green, child: Center(child: Text('Movie一覧')))), ], ), ToggleButtons: オンとオフの２状態を持つ横方向に並ぶ配列のボタンです。 Movie一覧12345678910111213141516171819202122232425262728293031Expanded( // 1. child: ListView.separated( itemBuilder: (context, index) { return Container( padding: EdgeInsets.symmetric(horizontal: 10, vertical: 10), // 2. child: Row( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Container(color: Colors.green, width: 90, height: 120), SizedBox(width: 15), Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Text('Title'), Text('2019-10-02'), Text( 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temportempor'), ], ), ) ], ), ); }, separatorBuilder: (context, index) =&gt; Divider(height: 1), itemCount: 10, ),), ListView:子供を並んで表示するが、大量データを持って、スクロールができる特徴です。 itemBuilder: 表示必要アイテムだけは計算するので、そのアイテムの計算方法の記述callbackです。 Row: Columnと同じですが、子供を横並びます。 注1: RowとColumnはスクロールができないので、表示切れない場合はこんなWarningが出ます。スクロールしたいでしたら、Listを使いましょう。 注2: Cross AxisとMain Axisについて 画像：flutter.dev 注3: Webのフレックスボックスのような自動改行したい場合、WrapのWidgetがあります。 まとめ基本的なWidgetを紹介しました。大体の画面はこれらのWidgetで構成されますので、使いこなすのがおすすめです。 Row, Column, Wrap List Container, SizedBox Text, ToggleButtons Padding, Center, Expanded","link":"/2019/08/21/flutter/movie-app-tutorial-part2/index/"},{"title":"[Flutter]iOSアプリチュートリアルPart1 - 始めに","text":"Flutterでモバイルアプリを作ってようモバイルアプリってAndroid=Java, iOS=Swiftのメインですね。 ただ、各OSの対応バージョンを開発するのは時間がかかりますし、一度アプリを作れば両方対応できるcross platformはいくつか存在しています。 本来ならばcrossplatformを使えば、楽でいけるはずだが、実際はそう簡単ではありません。 Hybridアプリ(Cordova等): HTML,JSでWebsiteのようなアプリを作って、モバイル上に動かせます。アプリ自体はWebViewであり、本質はWebなので、スピードは期待できない特徴です。 ReactNative: 「JSブリッジ」というアプリとOSの中間にある橋を使って、第３言語（主にJS)でcross platformを実現します。また、ReactNativeはHot Reloadというコード書きながら、即時結果確認できるので、人気がありそうです。問題は、アプリを動作するには、橋を渡って、OSに指示を出しなければならない為、その橋が混雑な状態になると、急激なスピード減少等に至るので、注意する必要があります。 Flutter:Googleが開発した最新のMobile Application UI Frameworkです。ReactNativeのような橋がなく、「本ネイティブ」と同等なレベルでアプリを動作するのが特徴です。直接OS下で動作するが、各OSのSDKを使用せず、自ら独特な実行環境を用意して、画面描画やイベント処理等全部その環境内で行います。理想的に言うと、Flutterを使えば、モバイルだけでなく、DesktopからWebまでどんな環境でも統一したUI、挙動を実現できるのです。 このシリーズでは実際のアプリを作りながら、Flutterについて理解していきます。 ゴール flutterの基本的なWidgetの使い方。 状態管理（state management)理解、Providerの使い方。複雑な状態を簡単に作れます。 Http, Json, Rest APIを使って、ネットワークと繋がります。 Reactive programmingの基礎知識を理解します。‐ Performance向上、Isolate, Cache。 Animationで魅力的なアプリを作ります。 …その他 1. Flutterとは コードを一度書くだけで、全platform対応というwrite once, run everywhereのUIframeworkです。 1.1. 特徴、なぜ他のframeworkと違っているのでしょうか FlutterはOSのSDKの頼らず、自ら画面を描画します。例えば、ReactNativeアプリでは「ここにボータン配置してね」というような指示をOSに指示し、OSはボータンを描画し、配置する一方、FlutterはターゲットOSに近い形のボータンを描画し、配置します。\\ 参照Link Flutterで作られたアプリはNativeのように見えるかもしれないが、実はNativeではありません。 Hot reloadコードを書きながら、即時コンパイルし、確認できる機能。これは本当に開発者の心に当たるポイントです。 NativeのARMコードにコンパイルリリースモードでビルドすると、ARMコードにコンパイルし、最高のスピードを実現します。 Material Themeはデフォルトに内蔵され、工夫せず、魅力的なアプリを安易に作れます。特にデザインに苦手な僕は、ありがたいところです。 Dartという言語「また新しい言語!!!」と思っちゃうですね。でも、C#やJavaと似ているので、すぐ覚えると思います。 1.2. なぜDartなのか？DartコンパイラーはJITとAoTという2モードがある為、Flutterの開発方針を実現できるようです。 JIT(Just in time)：HotReloadを実現させるモード。開発者に一番セルポイントです。 AoT(Ahead of time): 事前にNativeコードにコンパイルし（Cのように）、Flutterアプリの最高のスピードを実現させるモードです。 1.3. 「Everything is widget」という概念画面に表示Button, Labelといったコンポーネントは全部Widgetと言います。表示しないLayoutの部分もWidgetと言い、まさに全てがWidgetです。 1.4. Declarative Programming今まで命令的のImperative手法でアプリを開発するのは多いと思いますが、FlutterはDelarative手法を使います。 \\ 簡潔にいうと違い点は以下の通りです \\ *参照Link*Imperative手法 12345// Imperative styleb.setColor(red)b.clearChildren()ViewC c3 = new ViewC(...)b.add(c3) Declarative手法 12345// Declarative stylereturn ViewB( color: red, child: ViewC(...),) ※構造(structure)だけは宣言し、その構造をどう作るのは任せるって感じですね。 2. どんなアプリをつくりますか。2.1. Movies explorerMoviesのサービスAPIを使って、人気Moviesや俳優の情報を手に入れるアプリです。 2.2. 画面のWireframe Home画面 Search画面 詳細画面 レビュー画面 Profile画面 2.3. プロジェクト作成Mac, Windows, Linux全部対応しますが、僕はMacなので、Macの内容でまとめます。 ※iOSはMac環境で動作する必要です。 #1. Flutterダウンロードホームページ：https://flutter.dev/docs/get-started/install #2. Path設定 ~/.bash_profileを編集12# 以下、/path/to/flutterを自分のパスに変換し、保存export PATH=\"$PATH:/path/to/flutter/bin\" 12# 変更を適用するsource ~/.bash_profile #3. プロジェックと生成123cd /path/to/project/folderflutter create flutter_moviescd flutter_movies #4. IDEを立ち上がります。IntelliJ IDEAを推奨します。Download Link: https://www.jetbrains.com/idea/download/ #5. iOS/AndroidのSDKをインストールiOSの場合、Xcodeをインストールして、初期起動を済むと完了 #6. Simulatorを起動iOS SimulatorやAndroid Emulatorを起動してください。 #7. アプリをビルド1flutter run 結果 まとめ Flutterは真のcross platformソリューションのひとつです。 FlutterはDeclarative Programmingを使用します。 開発時に、JITでHot Reloadを実現し、Release時AOTコンパイルも最高のパーフォーマンスを実現します。 Part 2","link":"/2019/08/01/flutter/movie-app-tutorial-part1/index/"},{"title":"[Flutter]iOSアプリチュートリアルPart5 - MVVM, Refactoring, Provider","text":"ゴール Refactoring Providerの使い方 StatelessWidgetを最優先に使用する考え方 Refactoring全てmain.dartに記述し、管理できない状態になったので、ファイル別に分けてRefactoringしよう。 各画面をファイルそれぞれに分ける コンポーネント化 カスタマイズWidgetで、画面部分的にWidgetを作る。 HomePage _ToggleButtons：現在選択中インデックスを保ちたいので、StatefulWidget _MovieList: Movie一覧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class _HomePageState extends State&lt;HomePage&gt; { List&lt;String&gt; _menus = ['Popular', 'Top Rated', 'Upcoming', 'Now Playing']; List&lt;Movie&gt; _movies = []; String _title = ''; final _scrollController = ScrollController(); final random = Random(); @override void initState() { super.initState(); // 最初のアイテムを「選択中」に設定 this._title = this._menus[0]; this.fetchMovies(); } void fetchMovies() { this._movies = List.generate( random.nextInt(30) + 10, (index) =&gt; Movie( title: \"Title ${index + 1}\", release_date: \"2019-01-01\", overview: \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temportempor\", ), ); if (this._scrollController.hasClients) { this._scrollController.animateTo(0, duration: Duration(milliseconds: 300), curve: Curves.easeInOut); } } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(this._title), actions: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.search), onPressed: () { Navigator.push( context, NoAnimationRoute( builder: (context) =&gt; SearchPage(), ), ); }, ) ], ), body: Column( children: &lt;Widget&gt;[ _ToggleButtons( menus: this._menus, onSelectedIndexChanged: (index) { setState(() { this.fetchMovies(); this._title = this._menus[index]; }); }, ), _MovieList( scrollController: _scrollController, movies: _movies, ), ], ), ); }} _ToggleButtons 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class _ToggleButtons extends StatefulWidget { final List&lt;String&gt; menus; final void Function(int) onSelectedIndexChanged; const _ToggleButtons({ Key key, @required this.menus, @required this.onSelectedIndexChanged, }) : super(key: key); @override __ToggleButtonsState createState() =&gt; __ToggleButtonsState();}class __ToggleButtonsState extends State&lt;_ToggleButtons&gt; { List&lt;bool&gt; _isSelected = []; List&lt;Movie&gt; _movies = []; int _selectedIndex = 0; @override void initState() { super.initState(); this.resembleMenuState(); } @override void didUpdateWidget(_ToggleButtons oldWidget) { super.didUpdateWidget(oldWidget); this.resembleMenuState(); } void resembleMenuState() { this._isSelected = this.widget.menus.map&lt;bool&gt;((s) =&gt; false).toList(); this._isSelected[this._selectedIndex] = true; } @override Widget build(BuildContext context) { return Container( padding: EdgeInsets.all(10), child: ToggleButtons( children: this.widget.menus.map&lt;Widget&gt;((s) =&gt; Text(s)).toList(), onPressed: (index) { setState(() { this._selectedIndex = index; this.resembleMenuState(); this.widget.onSelectedIndexChanged(index); }); }, isSelected: this._isSelected, ), ); }} _MovieList 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class _MovieList extends StatelessWidget { const _MovieList({ Key key, @required ScrollController scrollController, @required List&lt;Movie&gt; movies, }) : _scrollController = scrollController, _movies = movies, super(key: key); final ScrollController _scrollController; final List&lt;Movie&gt; _movies; @override Widget build(BuildContext context) { return Expanded( child: ListView.separated( controller: this._scrollController, itemBuilder: (context, index) { final movie = this._movies[index]; return ListTile( onTap: () { Navigator.push(context, MaterialPageRoute(builder: (context) =&gt; MovieDetailPage())); }, title: Container( padding: EdgeInsets.symmetric(vertical: 5), child: Row( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Avatar(width: 90, height: 120), SizedBox(width: 15), Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Text(movie.title), Text(movie.release_date), Text(movie.overview), ], ), ) ], ), ), ); }, separatorBuilder: (context, index) =&gt; Divider(height: 1), itemCount: this._movies.length, ), ); }} MovieDetailPagePersonPage ProviderProviderは何？State managementのパッケージで、以下の昨日が整備される InheritedWidgetのsyntactic sugar 下位、上位とシブリングWidgetのデータフロー安易にできる DI 基本的にStatelessWidgetを使用し、メンテしやすいアプリを実現する インストール pubspec.yaml123dependencies: # 追加 provider: アイデア 上位WidgetはProviderと呼ばれ、下位に共有データを宣言する 下位WidgetはConsumerと呼ばれ、どのレベルにあっても、上位Widgetのデータを取得ができる Provider.of&lt;type&gt;は自動に現在のWidgetを起点にtypeとマッチする最初のデータを取得する。1234567891011121314151617181920class HomeScreen extends StatelessWidget { @override Widget build(BuildContext context) { return Provider&lt;String&gt;.value(value: \"Thanh Chung\", child: GreetingWidget()); }}class GreetingWidget extends StatelessWidget { @override Widget build(BuildContext context) { return Consumer&lt;String&gt;( builder: (context, value, child) { return Text(\"Hello $value\"); }, ); // 下記の書き方は同じ。短くて、便利だね // final value = Provider.of&lt;String&gt;(context); // return Text(\"Hello $value\"); }} ChangeNotifierデータが変更するに当たって通知機能をもつクラス MVVMパータンFlutterでよく採用されるパターン M: Modelアプリモデル V: ViewWidgetを指す。基本的にStatelessWidgetを使用する VM: ViewModelWidgetの表示データ、アクション等 StatelessWidgetを使うべき 状態が変更できない為、上位のProviderとしてStatefulWidgetを配置 ConsumerパターンでStatelessWidgetを作る BaseWidget 123456789101112131415161718192021222324252627282930313233343536373839404142class BaseWidget&lt;T extends ChangeNotifier&gt; extends StatefulWidget { final Widget Function(BuildContext context, T model, Widget child) builder; final T model; final Widget child; final Function(T) onModelReady; BaseWidget({ Key key, this.builder, this.model, this.child, this.onModelReady, }) : super(key: key); _BaseWidgetState&lt;T&gt; createState() =&gt; _BaseWidgetState&lt;T&gt;();}class _BaseWidgetState&lt;T extends ChangeNotifier&gt; extends State&lt;BaseWidget&lt;T&gt;&gt; { T model; @override void initState() { model = widget.model; if (widget.onModelReady != null) { widget.onModelReady(model); } super.initState(); } @override Widget build(BuildContext context) { return ChangeNotifierProvider&lt;T&gt;( builder: (context) =&gt; model, child: Consumer&lt;T&gt;( builder: widget.builder, child: widget.child, ), ); }} HomeViewModelview_models/home_vm.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445import 'dart:math';import 'package:flutter/material.dart';import 'package:flutter_movies/models/models.dart';final random = Random();class HomeViewModel extends ChangeNotifier { String appBarTitle = ''; List&lt;String&gt; menus = ['Popular', 'Top Rated', 'Upcoming', 'Now Playing']; List&lt;Movie&gt; movies = []; int selectedIndex = 0; List&lt;bool&gt; get isSelected { List&lt;bool&gt; results = this.menus.map&lt;bool&gt;((s) =&gt; false).toList(); results[this.selectedIndex] = true; return results; } HomeViewModel() { this.appBarTitle = this.menus[this.selectedIndex]; } void changeSelectedMenu(int targetIndex) { this.selectedIndex = targetIndex; this.appBarTitle = this.menus[targetIndex]; this.notifyListeners(); } void fetchMovies() async { this.movies = []; this.notifyListeners(); await Future.delayed(Duration(milliseconds: 300)); this.movies = List.generate( random.nextInt(30) + 10, (index) =&gt; Movie( title: \"Title ${index + 1}\", release_date: \"2019-01-01\", overview: \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temportempor\", ), ); this.notifyListeners(); }} Stateless HomePage BaseWidgetを使って、HomePageをStatelessWidgetに bodyは引数必要なく、非常に分かりやすくなったね。 ** home_page.dart** 123456789101112131415161718192021222324252627282930313233class HomePage extends StatelessWidget { @override Widget build(BuildContext context) { return BaseWidget&lt;HomeViewModel&gt;( model: HomeViewModel(), onModelReady: (vm) { vm.fetchMovies(); }, builder: (context, vm, child) { return Scaffold( appBar: AppBar( title: Text(vm.appBarTitle), actions: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.search), onPressed: () { Navigator.push(context, NoAnimationRoute(builder: (context) =&gt; SearchPage())); }, ) ], ), body: Column( children: &lt;Widget&gt;[ // 引数はなくなった _ToggleButtons(), _MovieList(), ], ), ); }, ); }} _ToggleButtons, _MovieList 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class _ToggleButtons extends StatelessWidget { @override Widget build(BuildContext context) { final vm = Provider.of&lt;HomeViewModel&gt;(context); return Container( padding: EdgeInsets.all(10), child: ToggleButtons( children: vm.menus.map&lt;Widget&gt;((s) =&gt; Text(s)).toList(), onPressed: (index) { vm.changeSelectedMenu(index); }, isSelected: vm.isSelected, ), ); }}class _MovieList extends StatelessWidget { @override Widget build(BuildContext context) { final vm = Provider.of&lt;HomeViewModel&gt;(context); return Expanded( child: ListView.separated( itemBuilder: (context, index) { final movie = vm.movies[index]; return ListTile( onTap: () { Navigator.push(context, MaterialPageRoute(builder: (context) =&gt; MovieDetailPage())); }, title: Container( padding: EdgeInsets.symmetric(vertical: 5), child: Row( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Avatar(width: 90, height: 120), SizedBox(width: 15), Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Text(movie.title), Text(movie.release_date), Text(movie.overview), ], ), ) ], ), ), ); }, separatorBuilder: (context, index) =&gt; Divider(height: 1), itemCount: vm.movies.length, ), ); }} WidgetはUIの役割だけに簡潔になった 処理は全てViewModelで行う。 これで、Widgetに触れなくても処理改修ができるので、scalabilityは向上したね。 残画面MovieDetailPageRefactoring 123456789101112131415161718192021222324252627282930313233343536373839404142class MovieDetailPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( body: CustomScrollView( slivers: &lt;Widget&gt;[ SliverAppBar( expandedHeight: 180, pinned: true, elevation: 0, flexibleSpace: FlexibleSpaceBar( title: Text(\"Joker\"), background: Stack( children: [ Positioned.fill( child: Container(color: Colors.blue), ), ], ), ), ), SliverList( delegate: SliverChildListDelegate( [ _Poster(), divider, Reviews(), divider, _Overview(), divider, _Credit(), divider, _Credit(), divider, ], ), ) ], ), ); }} 各Componentsを作ってみてください。 まとめ MVVMパータンベースでRefactoringを紹介した。 Providerを使って、拡張性が良い状態管理を実装した。次回はMoviesのAPIを使って、ネットワークのデータを撮りに行って、生々しいアプリを作ろう。","link":"/2019/11/01/flutter/movie-app-tutorial-part5/index/"},{"title":"[Flutter]iOSアプリチュートリアルPart6 - Networking: Movie Rest API","text":"今回はAPIを使って、実際のMoviesデータを表示しましょう。 ゴール Movie API ネットワーキング、RestAPI Asynchronous: Future, async, await非同期オペレーションを実装する為に、DartはFuture,async,awaitを用意しています。 asyncとawaitはほぼどの言語にでもあるから、言うまでもなく。でも、Futureって何？ FutureとはJavascriptのPromiseと似ている感じでしょうか。Futureは将来のどこかのタイミングで終わる予定のオペレーションの結果です。 Uncompleted Completed 正常Completed エラーCompleted という２状態があります。Dartホームページ https://dart.dev/codelabs/async-await に詳しく解説しますので、そちらをご参照ください 次は実際画面に応用しましょう Movies APIと連携APIKeyを取得APIの提供者：https://www.themoviedb.org/documentation/api\\登録して、APIkeyを取得してください。 Modelsmodels.dart 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Genre { final int id; final String name; Genre({ this.id, this.name, });}class Movie { final int id; final int vote_count; final double vote_average; final double popularity; final String title; final String overview; final String release_date; final String poster_path; final String backdrop_path; final String original_language; final String original_title; final bool video; final bool adult; final List&lt;Genre&gt; genres; Movie({ this.id, this.title = '', this.vote_average = 0, this.overview = '', this.release_date = '', this.popularity = 0, this.vote_count = 0, this.video = false, this.poster_path = '', this.adult = false, this.backdrop_path = '', this.original_language = '', this.original_title = '', this.genres = const [], }); factory Movie.fromMap(Map dict) { return Movie( id: dict[\"id\"], vote_count: dict[\"vote_count\"], vote_average: double.parse(dict[\"vote_average\"].toString()), popularity: double.parse(dict[\"popularity\"].toString()), title: dict[\"title\"], overview: dict[\"overview\"], release_date: dict[\"release_date\"], video: dict[\"video\"], poster_path: dict[\"poster_path\"], adult: dict[\"adult\"], backdrop_path: dict[\"backdrop_path\"], original_language: dict[\"original_language\"], original_title: dict[\"original_title\"], ); }} HTTPパッケージ追加pubspec.yaml 12dependencies: http: AvatarWidget1234567891011121314151617181920212223242526272829303132class Avatar extends StatelessWidget { final double width; final double height; final String url; const Avatar({ Key key, this.width, this.height, this.url, }) : super(key: key); @override Widget build(BuildContext context) { return Container( width: width, height: height, decoration: BoxDecoration( color: Colors.white, boxShadow: [ BoxShadow(color: Colors.grey.shade400, blurRadius: 8, offset: Offset(1, 5), spreadRadius: 2), ] ), child: this.url == null ? Container() : Image.network( this.url, fit: BoxFit.cover, ), ); }} TheMovieDbAPISingletonで、ネットワーキングやり取りは全部このクラスで行います。Dartの独特な実装方法で、Singletonを便利の使えます。services/themoviedb_api.dart 12345678910class TheMovieDbAPI { final String baseURL = \"https://api.themoviedb.org/3\"; final String apiKey = \"\"; // ★★★APIKeyを入れてください。 static final TheMovieDbAPI _instance = TheMovieDbAPI._internal(); factory TheMovieDbAPI() =&gt; _instance; TheMovieDbAPI._internal();} API使用する例 1final apiService = TheMovieDbAPI(); services/themoviedb_api.dart* 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import 'dart:convert';import 'package:flutter_movies/models/models.dart';import 'package:http/http.dart' as http;class TheMovieDbAPI { final String baseURL = \"https://api.themoviedb.org/3\"; final String apiKey = \"\"; // ★★★APIKeyを入れてください。 static final TheMovieDbAPI _instance = TheMovieDbAPI._internal(); factory TheMovieDbAPI() =&gt; _instance; TheMovieDbAPI._internal(); Future&lt;List&lt;Movie&gt;&gt; fetchMovies(String featured) async { final url = \"${this.baseURL}/movie/$featured?api_key=${this.apiKey}\"; final res = await http.get(url); final data = res.body; final dict = json.decode(data); final List arr = dict[\"results\"]; List&lt;Movie&gt; results = []; for (final dict in arr) { dict['poster_path'] = TheMovieDbImageUrl.resolveUrl(dict[\"poster_path\"], ImageSize.Small); results.add(Movie.fromMap(dict)); } return results; }}enum ImageSize { Small, Medium, Cast, Original }class TheMovieDbImageUrl { static final String small = \"https://image.tmdb.org/t/p/w154/\"; static final String medium = \"https://image.tmdb.org/t/p/w500/\"; static final String cast = \"https://image.tmdb.org/t/p/w185/\"; static final String original = \"https://image.tmdb.org/t/p/original/\"; static String resolveUrl(String path, ImageSize size) { switch (size) { case ImageSize.Small: return \"$small$path\"; break; case ImageSize.Medium: return \"$medium$path\"; break; case ImageSize.Cast: return \"$cast$path\"; break; case ImageSize.Original: return \"$original$path\"; break; } return path; }} AvatarWidget1234567891011121314151617181920212223242526272829303132class Avatar extends StatelessWidget { final double width; final double height; final String url; const Avatar({ Key key, this.width, this.height, this.url, }) : super(key: key); @override Widget build(BuildContext context) { return Container( width: width, height: height, decoration: BoxDecoration( color: Colors.white, boxShadow: [ BoxShadow(color: Colors.grey.shade400, blurRadius: 8, offset: Offset(1, 5), spreadRadius: 2), ] ), child: this.url == null ? Container() : Image.network( this.url, fit: BoxFit.cover, ), ); }} HomeViewModel12345678910111213141516171819202122232425262728293031323334353637383940414243444546import 'dart:math';import 'package:flutter/material.dart';import 'package:flutter_movies/models/models.dart';import 'package:flutter_movies/services/themoviedb_api.dart';final random = Random();class HomeViewModel extends ChangeNotifier { String appBarTitle = ''; List&lt;String&gt; menus = ['Popular', 'Top Rated', 'Upcoming', 'Now Playing']; List&lt;Movie&gt; movies = []; int selectedIndex = 0; List&lt;bool&gt; get isSelected { List&lt;bool&gt; results = this.menus.map&lt;bool&gt;((s) =&gt; false).toList(); results[this.selectedIndex] = true; return results; } HomeViewModel() { this.appBarTitle = this.menus[this.selectedIndex]; } void changeSelectedMenu(int targetIndex) { this.selectedIndex = targetIndex; this.appBarTitle = this.menus[targetIndex]; this.notifyListeners(); this.fetchMovies(); } void fetchMovies() async { String featured = 'popular'; if (selectedIndex == 1) { featured = \"top_rated\"; } else if (selectedIndex == 2) { featured = \"upcoming\"; } else if (selectedIndex == 3) { featured = \"now_playing\"; } final apiService = TheMovieDbAPI(); this.movies = await apiService.fetchMovies(featured); this.notifyListeners(); }} 結果 まとめ httpで実際のAPIと連携 Dartのasynchronous DartのSingletonパータン 詳細画面を作ってみてください。 次回は Cache,Performance向上 Dart Isolate Animation","link":"/2019/12/03/flutter/movie-app-tutorial-part6/index/"},{"title":"[Flutter]iOSアプリチュートリアルPart4 - インタラクティブ","text":"今回は画面のインタラクションや状態管理を追加します。 ゴール StatelessWidgetvsStatefulWidget理解 StatefulWidgetでインタラクティブ画面が作成できます。 StatelessWidget vs StatefulWidget StatelessWidget:constructor時に渡されるデータからどう構成するか記載するだけで、構成をビルドすると変更がありません。 StatefulWidget:Widgetの状態（変数、属性）を持ち、その状態によって画面構成が変動。 【例】 TextFieldはStatelessWidgetかStatefulWidgetか？👉 ユーザーの入力値を持ち、描画内容が変わるので、StatefulWidgetですね。 Textは？👉 インスタンスするときのテキストを表示し、変更ができない為、StatelessWidgetですね。 StatelessWidgetbuildメソッドでWidgetの構成を宣言します。 123456class HelloWorld extends StatelessWidget { @override Widget build(BuildContext context) { return Text(\"Hello World\"); }} StatefulWidgetStatelessWidgetより複雑なので、Life cycleメソッド理解する必要があります。【例】 12345678910111213141516171819202122class HelloWorld extends StatefulWidget { final String name; const HelloWorld({Key key, this.name}) : super(key: key); @override _HelloWorldState createState() =&gt; _HelloWorldState();}class _HelloWorldState extends State&lt;HelloWorld&gt; { String message; @override void initState() { super.initState(); // parentのデータを元に、Widgetのデータをセット this.message = \"Hello ${this.widget.name}\"; } @override Widget build(BuildContext context) { return Text(this.message); }} createState()Widgetの状態をもつObjectを作成します。👉_HelloWorldState: _はプライベートを表します。Dartにはよく使われる宣言パータン。👉HelloWorldはparent, _HelloWorldStateはchildと呼ばれることが多いです。 initState()Widgetをインスタンスする時、最初に呼び出されるメソッドparentのデータを元に自分の変数をイニシャライズ didChangeDependencies()Dependencyを変える時実行されるが、次は必ずbuildを実行する為、usecaseがよく分かりません😅network requestを実行すると思うが、buildは常に重たいので、side effectは避けるべきです。 build()Widgetの構成定義する一番重要メソッドですね。 didUpdateWidget()parentデータが変更されたさい、自分でもつ変数更新等の役割です。 setState()Widget状態を変更時に、リビルドの必要なことをframeworkに通知するメソッド dispose()Widgetがいらなくなった時、リソースを開放する処理の記載 HomePageStatefulWidgetに変更1234567891011class HomePage extends StatefulWidget { @override _HomePageState createState() =&gt; _HomePageState();}class _HomePageState extends State&lt;HomePage&gt; { @override Widget build(BuildContext context) { // 省略 }} ショートカットボタン 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class _HomePageState extends State&lt;HomePage&gt; { // 状態変数 List&lt;bool&gt; _isSelected = []; List&lt;String&gt; _menus = ['Popular', 'Top Rated', 'Upcoming', 'Now Playing']; @override void initState() { super.initState(); // 初期化 this._isSelected = this._menus.map&lt;bool&gt;((s) =&gt; false).toList(); // 最初のアイテムを「選択中」に設定 this._isSelected[0] = true; } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Popular'), actions: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.search), onPressed: () { Navigator.push( context, NoAnimationRoute( builder: (context) =&gt; SearchPage(), ), ); }, ) ], ), body: Column( children: &lt;Widget&gt;[ Container( padding: EdgeInsets.all(10), child: ToggleButtons( children: this._menus.map&lt;Widget&gt;((s) =&gt; Text(s)).toList(), onPressed: (index) { setState(() { // タップしたアイテムだけは「選択中」に設定 for (int i = 0; i &lt; this._isSelected.length; i++) { if (i == index) { this._isSelected[i] = true; } else { this._isSelected[i] = false; } } }); }, isSelected: this._isSelected, ), ), // 省略 ], ), ); }} Movie一覧 Movieオブジェクトを作ります。 1234567891011class Movie { final String title; final String release_date; final String overview; Movie({ this.title, this.release_date, this.overview, });} release_dateの名称になんか違和感を感じましたか？実はreleaseDateが望ましいけど、今回APIと連携する予定なので、API名称と合わせた方が楽だなと〜。 一覧更新 12345678910111213141516// 追加List&lt;Movie&gt; _movies = [];@overridevoid initState() { super.initState(); // データフェッチ this._movies = List.generate( 10, (index) =&gt; Movie( title: \"Title ${index + 1}\", release_date: \"2019-01-01\", overview: \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temportempor\", ), );} 12345678910111213141516171819202122232425262728293031323334353637383940@overrideWidget build(BuildContext context) { // 省略 Expanded( child: ListView.separated( itemBuilder: (context, index) { // 1. 行データ取得 final movie = this._movies[index]; return ListTile( onTap: () { Navigator.push(context, MaterialPageRoute(builder: (context) =&gt; MovieDetailPage())); }, title: Container( padding: EdgeInsets.symmetric(vertical: 5), child: Row( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Avatar(width: 90, height: 120), SizedBox(width: 15), Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Text(movie.title), Text(movie.release_date), Text(movie.overview), ], ), ) ], ), ), ); }, separatorBuilder: (context, index) =&gt; Divider(height: 1), // 2. Listの行数 itemCount: this._movies.length, ), ),} 結果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116class _HomePageState extends State&lt;HomePage&gt; { List&lt;bool&gt; _isSelected = []; List&lt;String&gt; _menus = ['Popular', 'Top Rated', 'Upcoming', 'Now Playing']; List&lt;Movie&gt; _movies = []; String _title = ''; final _scrollController = ScrollController(); final random = Random(); @override void initState() { super.initState(); this._isSelected = this._menus.map&lt;bool&gt;((s) =&gt; false).toList(); // 最初のアイテムを「選択中」に設定 this._isSelected[0] = true; this._title = this._menus[0]; this.fetchMovies(); } void fetchMovies() { this._movies = List.generate( random.nextInt(30) + 10, (index) =&gt; Movie( title: \"Title ${index + 1}\", release_date: \"2019-01-01\", overview: \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod temportempor\", ), ); if (this._scrollController.hasClients) { this._scrollController.animateTo(0, duration: Duration(milliseconds: 300), curve: Curves.easeInOut); } } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(this._title), actions: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.search), onPressed: () { Navigator.push( context, NoAnimationRoute( builder: (context) =&gt; SearchPage(), ), ); }, ) ], ), body: Column( children: &lt;Widget&gt;[ Container( padding: EdgeInsets.all(10), child: ToggleButtons( children: this._menus.map&lt;Widget&gt;((s) =&gt; Text(s)).toList(), onPressed: (index) { setState(() { this._title = this._menus[index]; this.fetchMovies(); // タップしたアイテムだけは「選択中」に設定 for (int i = 0; i &lt; this._isSelected.length; i++) { if (i == index) { this._isSelected[i] = true; } else { this._isSelected[i] = false; } } }); }, isSelected: this._isSelected, ), ), Expanded( child: ListView.separated( controller: this._scrollController, itemBuilder: (context, index) { final movie = this._movies[index]; return ListTile( onTap: () { Navigator.push(context, MaterialPageRoute(builder: (context) =&gt; MovieDetailPage())); }, title: Container( padding: EdgeInsets.symmetric(vertical: 5), child: Row( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Avatar(width: 90, height: 120), SizedBox(width: 15), Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Text(movie.title), Text(movie.release_date), Text(movie.overview), ], ), ) ], ), ), ); }, separatorBuilder: (context, index) =&gt; Divider(height: 1), itemCount: this._movies.length, ), ), ], ), ); }} まとめStatefulWidgetを紹介しました。基本的にはStatefulWidgetを使えば、どんなインタラクティブ画面でも作れますがこれより複雑になると、痛くなり、現実ではないですね。次回は、Providerと言う状態管理ライブラリを使って、scalabilityを持たせましょう。","link":"/2019/10/08/flutter/movie-app-tutorial-part4/index/"}],"tags":[{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"apache","slug":"apache","link":"/tags/apache/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"tip","slug":"tip","link":"/tags/tip/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"bom","slug":"bom","link":"/tags/bom/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"postgres","slug":"postgres","link":"/tags/postgres/"},{"name":"coprocess","slug":"coprocess","link":"/tags/coprocess/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"crossplatform","slug":"crossplatform","link":"/tags/crossplatform/"}],"categories":[]}